{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/CarbonCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// CarbonCoin.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { ICarbonCoin } from \"./interface/ICarbonCoin.sol\";\nimport { ICarbonCoinConfig } from \"./interface/ICarbonCoinConfig.sol\";\nimport { ISomniaExchangeRouter02 } from \"./interface/ISomniaExchangeRouter02.sol\";\n\n\ncontract CarbonCoin is ICarbonCoin, ERC20, ReentrancyGuard, Pausable {\n    // Bonding curve parameters (immutable after deployment)\n    uint256 public immutable VIRTUAL_ETH;\n    uint256 public immutable VIRTUAL_TOKENS;\n    uint256 public immutable MAX_SUPPLY;\n    uint256 public immutable GRADUATION_THRESHOLD;\n\n    // State variables\n    uint256 public realEthReserves;\n    uint256 public realTokenSupply;\n    uint256 public immutable launchTime;\n    address public immutable creator;\n    address public immutable config;\n    address public immutable launcher;\n    bool public hasGraduated;\n\n    PriceSnapshot[] public recentPrices;\n    uint256 public circuitBreakerTriggeredAt;\n    uint256 public volatilityMoveCount;\n    uint256 public lastVolatilityReset;\n\n    mapping(address => uint256) public lastBuyTime;\n    mapping(address => uint256) public lastWhaleTradeTime;\n    mapping(address => WhaleIntent) public pendingWhaleIntents;\n    mapping(address => bool) public isBlacklisted;\n    mapping(address => bool) public whitelist;\n\n    // Emergency withdrawal protection\n    uint256 public lastGraduationAttempt;\n    uint256 public constant GRADUATION_COOLDOWN = 1 hours;\n\n    ISomniaExchangeRouter02 public immutable dexRouter;\n    address public dexPair;\n\n    /**\n     * @notice Constructor for the CarbonCoin contract.\n     * @dev Initializes the token with its name, symbol, creator, and Somnia Exchange router.\n     * It also whitelists the creator and the launcher contract to bypass certain restrictions.\n     * @param name The name of the token.\n     * @param symbol The symbol of the token.\n     * @param _creator The address of the token creator.\n     * @param _router The address of the Somnia Exchange V2 router.\n     * @param _config The address of the token configuration contract.\n     * @param bondingCurveConfig The bonding curve parameters.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _creator,\n        address _router,\n        address _config,\n        BondingCurveConfig memory bondingCurveConfig\n    ) ERC20(name, symbol) {\n        // Validate inputs\n        require(_creator != address(0), \"Invalid creator\");\n        require(_router != address(0), \"Invalid router\");\n        require(_config != address(0), \"Invalid config\");\n\n        creator = _creator;\n        launcher = msg.sender;\n        config = _config;\n        dexRouter = ISomniaExchangeRouter02(_router);\n        launchTime = block.timestamp;\n\n        // Set bonding curve config (immutable)\n        VIRTUAL_ETH = bondingCurveConfig.virtualEth;\n        VIRTUAL_TOKENS = bondingCurveConfig.virtualTokens;\n        MAX_SUPPLY = bondingCurveConfig.maxSupply;\n        GRADUATION_THRESHOLD = bondingCurveConfig.graduationThreshold;\n\n        // Whitelist creator and launcher from restrictions\n        whitelist[_creator] = true;\n        whitelist[msg.sender] = true;\n\n        // Emit deployment event for indexing\n        emit TokenDeployed(\n            address(this),\n            _creator,\n            name,\n            symbol,\n            MAX_SUPPLY,\n            GRADUATION_THRESHOLD,\n            block.timestamp\n        );\n    }\n\n    // Allow receiving ETH\n    receive() external payable {\n        revert(\"Use buy() function\");\n    }\n\n    /**\n     * @notice Get the current token price in ETH.\n     * @dev Calculates the price based on the bonding curve's virtual and real reserves.\n     * @return The current price of one token in ETH.\n     */\n    function getCurrentPrice() public view returns (uint256) {\n        uint256 totalEth = VIRTUAL_ETH + realEthReserves;\n        uint256 totalTokens = VIRTUAL_TOKENS - realTokenSupply;\n        return (totalEth * 10**18) / totalTokens;\n    }\n\n    /**\n     * @notice Calculate the amount of tokens received for a given ETH input.\n     * @dev The calculation is based on the bonding curve formula and includes the buy fee.\n     * @param ethIn The amount of ETH to be spent.\n     * @return The amount of tokens that will be received.\n     */\n    function calculateTokensOut(uint256 ethIn) public view returns (uint256) {\n        if (ethIn == 0) return 0;\n\n        ICarbonCoinConfig.FeeConfig memory feeConfig = _getFeeConfig();\n\n        uint256 ethAfterFee = (ethIn * (10000 - feeConfig.buyFee)) / 10000;\n\n        uint256 k = (VIRTUAL_ETH + realEthReserves) * (VIRTUAL_TOKENS - realTokenSupply);\n        uint256 newTotalEth = VIRTUAL_ETH + realEthReserves + ethAfterFee;\n        uint256 newTotalTokens = k / newTotalEth;\n        uint256 newRealSupply = VIRTUAL_TOKENS - newTotalTokens;\n\n        return newRealSupply - realTokenSupply;\n    }\n\n    /**\n     * @notice Calculate the amount of ETH needed to buy a specific amount of tokens.\n     * @dev The calculation is based on the bonding curve formula and includes the buy fee.\n     * @param tokensOut The desired amount of tokens.\n     * @return The amount of ETH required to purchase the specified tokens.\n     */\n    function calculateEthIn(uint256 tokensOut) public view returns (uint256) {\n        if (tokensOut == 0) return 0;\n\n        ICarbonCoinConfig.FeeConfig memory feeConfig = _getFeeConfig();\n\n        uint256 k = (VIRTUAL_ETH + realEthReserves) * (VIRTUAL_TOKENS - realTokenSupply);\n        uint256 newRealSupply = realTokenSupply + tokensOut;\n        uint256 newTotalTokens = VIRTUAL_TOKENS - newRealSupply;\n        uint256 newTotalEth = k / newTotalTokens;\n        uint256 newEthReserves = newTotalEth - VIRTUAL_ETH;\n        uint256 ethNeeded = newEthReserves - realEthReserves;\n\n        return (ethNeeded * 10000) / (10000 - feeConfig.buyFee);\n    }\n\n    /**\n     * @notice Calculate the amount of ETH received when selling a specific amount of tokens.\n     * @dev The calculation is based on the bonding curve formula and includes the sell fee.\n     * @param tokensIn The amount of tokens to be sold.\n     * @return The amount of ETH that will be received.\n     */\n    function calculateEthOut(uint256 tokensIn) public view returns (uint256) {\n        if (tokensIn == 0) return 0;\n\n        ICarbonCoinConfig.FeeConfig memory feeConfig = _getFeeConfig();\n\n        uint256 k = (VIRTUAL_ETH + realEthReserves) * (VIRTUAL_TOKENS - realTokenSupply);\n        uint256 newRealSupply = realTokenSupply - tokensIn;\n        uint256 newTotalTokens = VIRTUAL_TOKENS - newRealSupply;\n        uint256 newTotalEth = k / newTotalTokens;\n        uint256 newEthReserves = newTotalEth - VIRTUAL_ETH;\n        uint256 ethOut = realEthReserves - newEthReserves;\n\n        return (ethOut * (10000 - feeConfig.sellFee)) / 10000;\n    }\n\n    /**\n     * @notice Allows a user to buy tokens with ETH.\n     * @dev This function is the main entry point for purchasing tokens. It includes anti-bot, circuit breaker, and trade size checks.\n     * If the trade is identified as a whale trade, it is delegated to the _handleWhaleBuy function.\n     * @param minTokensOut The minimum number of tokens the user is willing to accept for their ETH.\n     */\n    function buy(uint256 minTokensOut) external payable nonReentrant whenNotPaused {\n        // Inlined antiBotProtection modifier\n        require(msg.sender == tx.origin, \"Contract call not allowed\");\n        require(!isBlacklisted[msg.sender], \"Blacklisted\");\n\n        ICarbonCoinConfig.AntiBotConfig memory botConfig = _getAntiBotConfig();\n\n        if (block.timestamp < launchTime + botConfig.antiBotDuration) {\n            require(msg.value <= botConfig.maxBuyAmountEarly || whitelist[msg.sender], \"Buy amount too high\");\n        }\n\n        if (!whitelist[msg.sender]) {\n            if (lastBuyTime[msg.sender] != 0) {\n                require(block.timestamp >= lastBuyTime[msg.sender] + botConfig.cooldownPeriod, \"Cooldown active\");\n            }\n        }\n        lastBuyTime[msg.sender] = block.timestamp;\n\n        // Inlined circuitBreakerCheck modifier\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        if (circuitBreakerTriggeredAt > 0) {\n            if (block.timestamp < circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration) {\n                revert CircuitBreakerActive();\n            } else {\n                circuitBreakerTriggeredAt = 0;\n                emit CircuitBreakerReset(block.timestamp);\n            }\n        }\n\n        // Inlined tradeSizeCheck modifier\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        if (!whitelist[msg.sender]) {\n            require(msg.value <= whaleConfig.maxTradeSize, \"Trade size too large\");\n        }\n\n        if (hasGraduated) revert AlreadyGraduated();\n\n        if (msg.value < botConfig.minBuyAmount) revert InvalidAmount();\n\n        // Check if this is a whale trade\n        bool isWhaleTrade = msg.value >= whaleConfig.whaleThreshold && !whitelist[msg.sender];\n\n        if (isWhaleTrade) {\n            _handleWhaleBuy(msg.value, minTokensOut);\n            return;\n        }\n\n        _executeBuy(msg.sender, msg.value, minTokensOut);\n    }\n\n    /**\n     * @notice Internal function to execute a token purchase.\n     * @dev This function handles the core logic of a buy transaction, including calculating tokens out, checking for slippage and max supply,\n     * updating reserves, minting tokens, and handling fees.\n     * @param buyer The address of the user purchasing tokens.\n     * @param ethAmount The amount of ETH being spent.\n     * @param minTokensOut The minimum number of tokens the user is willing to accept.\n     */\n    function _executeBuy(address buyer, uint256 ethAmount, uint256 minTokensOut) internal {\n        uint256 priceBefore = getCurrentPrice();\n        uint256 tokensOut = calculateTokensOut(ethAmount);\n        if (tokensOut < minTokensOut) revert SlippageTooHigh();\n        if (realTokenSupply + tokensOut > MAX_SUPPLY) revert ExceedsMaxSupply();\n\n        ICarbonCoinConfig.FeeConfig memory feeConfig = _getFeeConfig();\n        ICarbonCoinConfig.AntiBotConfig memory botConfig = _getAntiBotConfig();\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n\n        // Check max wallet before minting (skip for whitelisted)\n        if (!whitelist[buyer]) {\n            uint256 maxWallet = (MAX_SUPPLY * botConfig.maxWalletPercentage) / 10000;\n            if (balanceOf(buyer) + tokensOut > maxWallet) revert ExceedsMaxWallet();\n        }\n\n        uint256 ethAfterFee = (ethAmount * (10000 - feeConfig.buyFee)) / 10000;\n        uint256 fee = ethAmount - ethAfterFee;\n\n        realEthReserves += ethAfterFee;\n        realTokenSupply += tokensOut;\n\n        uint256 priceAfter = getCurrentPrice();\n\n        // Check price impact (skip for small buys and whitelisted)\n        if (!whitelist[buyer] && ethAmount >= 1 ether) {\n            uint256 priceImpact = ((priceAfter - priceBefore) * 10000) / priceBefore;\n\n            if (priceImpact > cbConfig.maxPriceImpact) {\n                emit HighPriceImpact(buyer, priceImpact, block.timestamp);\n\n                // Trigger circuit breaker for extreme impact\n                if (priceImpact > cbConfig.maxPriceImpact * 2) {\n                    _triggerCircuitBreaker(\"Excessive price impact\");\n                    revert PriceImpactTooHigh();\n                }\n            }\n        }\n\n        // Track volatility\n        _trackVolatility(priceAfter);\n\n        _mint(buyer, tokensOut);\n\n        // Send fee to launcher\n        if (fee > 0) {\n            (bool success, ) = payable(launcher).call{value: fee}(\"\");\n            require(success, \"Fee transfer failed\");\n        }\n\n        emit TokensPurchased(\n            buyer,\n            ethAmount,\n            tokensOut,\n            priceAfter,\n            realEthReserves,\n            realTokenSupply,\n            block.timestamp\n        );\n\n        // Emit periodic price updates for charting\n        emit PriceUpdate(priceAfter, realEthReserves, realTokenSupply, block.timestamp);\n\n        // Check if graduation threshold reached\n        if (realEthReserves >= GRADUATION_THRESHOLD) {\n            _graduate();\n        }\n    }\n\n    /**\n     * @notice Internal function to handle whale buy transactions.\n     * @dev This function enforces a cooldown period and an intent-to-trade mechanism for large buy orders to prevent manipulation.\n     * @param ethAmount The amount of ETH being spent.\n     * @param minTokensOut The minimum number of tokens the user is willing to accept.\n     */\n    function _handleWhaleBuy(uint256 ethAmount, uint256 minTokensOut) internal {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n\n        // Check if whale has cooldown active\n        if (lastWhaleTradeTime[msg.sender] > 0) {\n            if (block.timestamp < lastWhaleTradeTime[msg.sender] + whaleConfig.whaleDelay) {\n                revert WhaleDelayActive();\n            }\n        }\n\n        // Check if there's a pending intent\n        WhaleIntent storage intent = pendingWhaleIntents[msg.sender];\n\n        if (intent.intentTime == 0) {\n            // No intent exists, register one\n            intent.amount = ethAmount;\n            intent.intentTime = block.timestamp;\n            intent.isBuy = true;\n            intent.executed = false;\n\n            emit WhaleIntentRegistered(\n                msg.sender,\n                ethAmount,\n                true,\n                block.timestamp + whaleConfig.whaleDelay,\n                block.timestamp\n            );\n\n            revert WhaleIntentRequired();\n        }\n\n        // Intent exists, check if enough time has passed\n        if (block.timestamp < intent.intentTime + whaleConfig.whaleDelay) {\n            revert WhaleIntentNotReady();\n        }\n\n        // Verify intent matches current trade\n        require(intent.isBuy, \"Intent is for sell, not buy\");\n        require(!intent.executed, \"Intent already executed\");\n        require(intent.amount == ethAmount, \"Amount must match intent\");\n\n        // Execute the trade\n        intent.executed = true;\n        lastWhaleTradeTime[msg.sender] = block.timestamp;\n\n        emit WhaleTradeExecuted(msg.sender, ethAmount, true, block.timestamp);\n\n        _executeBuy(msg.sender, ethAmount, minTokensOut);\n\n        // Clean up intent\n        delete pendingWhaleIntents[msg.sender];\n    }\n\n    /**\n     * @notice Allows a user to sell tokens for ETH.\n     * @dev This function is the main entry point for selling tokens. It includes checks for graduation, amount, and balance.\n     * It also enforces sell limits and delegates to _handleWhaleSell if the trade is large enough.\n     * @param tokensIn The amount of tokens to sell.\n     * @param minEthOut The minimum amount of ETH the user is willing to accept.\n     */\n    function sell(uint256 tokensIn, uint256 minEthOut) external nonReentrant whenNotPaused {\n        // Inlined circuitBreakerCheck modifier\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        if (circuitBreakerTriggeredAt > 0) {\n            if (block.timestamp < circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration) {\n                revert CircuitBreakerActive();\n            } else {\n                circuitBreakerTriggeredAt = 0;\n                emit CircuitBreakerReset(block.timestamp);\n            }\n        }\n\n        if (hasGraduated) revert AlreadyGraduated();\n        if (tokensIn == 0) revert InvalidAmount();\n        if (balanceOf(msg.sender) < tokensIn) revert InvalidAmount();\n\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n\n        // Check sell limits (skip for whitelisted)\n        if (!whitelist[msg.sender]) {\n            uint256 maxSellAmount = (realTokenSupply * whaleConfig.maxSellPercentage) / 10000;\n            if (tokensIn > maxSellAmount) revert SellAmountTooLarge();\n        }\n\n        uint256 ethOut = calculateEthOut(tokensIn);\n\n        // Check if this is a whale trade\n        bool isWhaleTrade = ethOut >= whaleConfig.whaleThreshold && !whitelist[msg.sender];\n\n        if (isWhaleTrade) {\n            _handleWhaleSell(tokensIn, minEthOut, ethOut);\n            return;\n        }\n\n        _executeSell(msg.sender, tokensIn, minEthOut, ethOut);\n    }\n\n    /**\n     * @notice Internal function to execute a token sale.\n     * @dev This function handles the core logic of a sell transaction, including checking for slippage and liquidity,\n     * updating reserves, burning tokens, and transferring ETH to the seller and fees to the launcher.\n     * It also checks for price impact and tracks volatility.\n     * @param seller The address of the user selling tokens.\n     * @param tokensIn The amount of tokens being sold.\n     * @param minEthOut The minimum amount of ETH the user is willing to accept.\n     * @param ethOut The calculated amount of ETH to be received.\n     */\n    function _executeSell(address seller, uint256 tokensIn, uint256 minEthOut, uint256 ethOut) internal {\n        if (ethOut < minEthOut) revert SlippageTooHigh();\n        if (ethOut > realEthReserves) revert InsufficientLiquidity();\n\n        ICarbonCoinConfig.FeeConfig memory feeConfig = _getFeeConfig();\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n\n        uint256 priceBefore = getCurrentPrice();\n        uint256 ethAfterFee = (ethOut * (10000 - feeConfig.sellFee)) / 10000;\n        uint256 fee = ethOut - ethAfterFee;\n\n        realEthReserves -= ethOut;\n        realTokenSupply -= tokensIn;\n\n        uint256 priceAfter = getCurrentPrice();\n\n        // Check price impact for large sells\n        if (!whitelist[seller]) {\n            uint256 priceImpact = ((priceBefore - priceAfter) * 10000) / priceBefore;\n\n            if (priceImpact > cbConfig.maxPriceImpact) {\n                emit HighPriceImpact(seller, priceImpact, block.timestamp);\n\n                // Trigger circuit breaker for extreme impact\n                if (priceImpact > cbConfig.maxPriceImpact * 2) {\n                    _triggerCircuitBreaker(\"Excessive negative price impact\");\n                    revert PriceImpactTooHigh();\n                }\n            }\n        }\n\n        // Track volatility\n        _trackVolatility(priceAfter);\n\n        _burn(seller, tokensIn);\n\n        (bool success1, ) = payable(seller).call{value: ethAfterFee}(\"\");\n        require(success1, \"ETH transfer failed\");\n\n        // Send fee to launcher\n        if (fee > 0) {\n            (bool success2, ) = payable(launcher).call{value: fee}(\"\");\n            require(success2, \"Fee transfer failed\");\n        }\n\n        emit TokensSold(\n            seller,\n            tokensIn,\n            ethOut,\n            priceAfter,\n            realEthReserves,\n            realTokenSupply,\n            block.timestamp\n        );\n\n        // Emit periodic price updates for charting\n        emit PriceUpdate(priceAfter, realEthReserves, realTokenSupply, block.timestamp);\n    }\n\n    function _handleWhaleSell(uint256 tokensIn, uint256 minEthOut, uint256 ethOut) internal {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n\n        // Check if whale has cooldown active\n        if (lastWhaleTradeTime[msg.sender] > 0) {\n            if (block.timestamp < lastWhaleTradeTime[msg.sender] + whaleConfig.whaleDelay) {\n                revert WhaleDelayActive();\n            }\n        }\n\n        // Check if there's a pending intent\n        WhaleIntent storage intent = pendingWhaleIntents[msg.sender];\n\n        if (intent.intentTime == 0) {\n            // No intent exists, register one\n            intent.amount = tokensIn;\n            intent.intentTime = block.timestamp;\n            intent.isBuy = false;\n            intent.executed = false;\n\n            emit WhaleIntentRegistered(\n                msg.sender,\n                tokensIn,\n                false,\n                block.timestamp + whaleConfig.whaleDelay,\n                block.timestamp\n            );\n\n            revert WhaleIntentRequired();\n        }\n\n        // Intent exists, check if enough time has passed\n        if (block.timestamp < intent.intentTime + whaleConfig.whaleDelay) {\n            revert WhaleIntentNotReady();\n        }\n\n        // Verify intent matches current trade\n        require(!intent.isBuy, \"Intent is for buy, not sell\");\n        require(!intent.executed, \"Intent already executed\");\n        require(intent.amount == tokensIn, \"Amount must match intent\");\n\n        // Execute the trade\n        intent.executed = true;\n        lastWhaleTradeTime[msg.sender] = block.timestamp;\n\n        emit WhaleTradeExecuted(msg.sender, tokensIn, false, block.timestamp);\n\n        _executeSell(msg.sender, tokensIn, minEthOut, ethOut);\n\n        // Clean up intent\n        delete pendingWhaleIntents[msg.sender];\n    }\n\n    // Graduate to Somnia Exchange with protection against griefing\n    function _graduate() internal {\n        if (hasGraduated) revert AlreadyGraduated();\n\n        // Prevent rapid graduation attempts (griefing protection)\n        if (block.timestamp < lastGraduationAttempt + GRADUATION_COOLDOWN) {\n            revert GraduationCooldownActive();\n        }\n        lastGraduationAttempt = block.timestamp;\n\n        hasGraduated = true;\n\n        // Mint remaining tokens for liquidity\n        uint256 remainingTokens = MAX_SUPPLY - realTokenSupply;\n        _mint(address(this), remainingTokens);\n\n        // Approve router to spend tokens\n        _approve(address(this), address(dexRouter), remainingTokens);\n\n        // Add liquidity (auto-creates pair)\n        uint256 ethForLiquidity = realEthReserves;\n\n        try dexRouter.addLiquidityETH{value: ethForLiquidity}(\n            address(this),\n            remainingTokens,\n            (remainingTokens * 95) / 100, // 5% slippage tolerance\n            (ethForLiquidity * 95) / 100,\n            creator, // Send LP Tokens to Creator  OR   address(0), // Burn LP tokens\n            block.timestamp + 60\n        ) returns (uint amountToken, uint amountETH, uint) {\n            emit Graduated(\n                address(this),\n                dexPair,\n                amountToken,\n                amountETH,\n                getCurrentPrice(),\n                block.timestamp\n            );\n\n            // Final liquidity snapshot\n            emit LiquiditySnapshot(0, 0, block.timestamp);\n        } catch {\n            // If graduation fails, revert state\n            hasGraduated = false;\n            _burn(address(this), remainingTokens);\n            revert(\"Graduation failed\");\n        }\n    }\n\n    // Manual graduation with cooldown (emergency only)\n    function forceGraduate() external onlyAuthorized {\n        if (realEthReserves < GRADUATION_THRESHOLD) revert InsufficientLiquidity();\n        _graduate();\n    }\n\n    // Admin functions for anti-bot management\n    function blacklistAddress(address account, bool blacklisted) external onlyAuthorized {\n        isBlacklisted[account] = blacklisted;\n        emit AddressBlacklisted(account, blacklisted, block.timestamp);\n        if (blacklisted) {\n            emit BotDetected(account, \"Manually blacklisted\", block.timestamp);\n        }\n    }\n\n    function addToWhitelist(address account) external onlyAuthorized {\n        whitelist[account] = true;\n        emit AddressWhitelisted(account, true, block.timestamp);\n    }\n\n    function removeFromWhitelist(address account) external onlyAuthorized {\n        require(account != creator && account != launcher, \"Cannot remove core addresses\");\n        whitelist[account] = false;\n        emit AddressWhitelisted(account, false, block.timestamp);\n    }\n\n    // Emergency pause (can only be called before graduation)\n    function pause() external onlyAuthorized {\n        if (hasGraduated) revert AlreadyGraduated();\n        _pause();\n        emit TradingPaused(block.timestamp);\n    }\n\n    function unpause() external onlyAuthorized {\n        _unpause();\n        emit TradingUnpaused(block.timestamp);\n    }\n\n    // Emergency withdrawal (only if something goes wrong before graduation)\n    function emergencyWithdraw() external onlyAuthorized {\n        if (hasGraduated) revert AlreadyGraduated();\n        require(paused(), \"Must be paused first\");\n\n        uint256 balance = address(this).balance;\n        (bool success, ) = payable(launcher).call{value: balance}(\"\");\n        require(success, \"Withdrawal failed\");\n\n        emit EmergencyWithdraw(launcher, balance, block.timestamp);\n        emit LiquiditySnapshot(0, 0, block.timestamp);\n    }\n\n    // Circuit breaker internal functions\n    function _triggerCircuitBreaker(string memory reason) internal {\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        circuitBreakerTriggeredAt = block.timestamp;\n        emit CircuitBreakerTriggered(reason, block.timestamp, cbConfig.circuitBreakerDuration);\n    }\n\n    function _trackVolatility(uint256 currentPrice) internal {\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n\n        // Reset counter if window expired\n        if (block.timestamp > lastVolatilityReset + cbConfig.volatilityWindow) {\n            volatilityMoveCount = 0;\n            lastVolatilityReset = block.timestamp;\n            // Clear old price snapshots\n            delete recentPrices;\n        }\n\n        // Record price snapshot\n        recentPrices.push(PriceSnapshot({\n            price: currentPrice,\n            timestamp: block.timestamp\n        }));\n\n        uint256 pricesLength = recentPrices.length;\n        // Check for significant price moves\n        if (pricesLength > 1) {\n            uint256 lastPrice = recentPrices[pricesLength - 2].price;\n            uint256 priceChange = currentPrice > lastPrice\n                ? ((currentPrice - lastPrice) * 10000) / lastPrice\n                : ((lastPrice - currentPrice) * 10000) / lastPrice;\n\n            // Count moves greater than 5%\n            if (priceChange > 500) {\n                volatilityMoveCount++;\n\n                if (volatilityMoveCount >= cbConfig.maxVolatilityMoves) {\n                    emit VolatilityWarning(volatilityMoveCount, block.timestamp);\n                    _triggerCircuitBreaker(\"Excessive volatility detected\");\n                }\n            }\n        }\n    }\n\n    // Manual circuit breaker control\n    function triggerCircuitBreaker(string memory reason) external onlyAuthorized {\n        _triggerCircuitBreaker(reason);\n    }\n\n    function resetCircuitBreaker() external onlyAuthorized {\n        circuitBreakerTriggeredAt = 0;\n        volatilityMoveCount = 0;\n        lastVolatilityReset = block.timestamp;\n        delete recentPrices;\n        emit CircuitBreakerReset(block.timestamp);\n    }\n\n    function getCircuitBreakerStatus() external view returns (\n        bool isActive,\n        uint256 triggeredAt,\n        uint256 timeRemaining,\n        uint256 volatilityMoves\n    ) {\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        uint256 _circuitBreakerTriggeredAt = circuitBreakerTriggeredAt;\n\n        isActive = _circuitBreakerTriggeredAt > 0 &&\n                   block.timestamp < _circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration;\n        triggeredAt = _circuitBreakerTriggeredAt;\n\n        if (isActive) {\n            timeRemaining = (_circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration) - block.timestamp;\n        } else {\n            timeRemaining = 0;\n        }\n\n        volatilityMoves = volatilityMoveCount;\n    }\n\n    // Whale trade management\n    function cancelWhaleIntent() external {\n        WhaleIntent storage intent = pendingWhaleIntents[msg.sender];\n        if (intent.intentTime == 0) revert NoWhaleIntentFound();\n        require(!intent.executed, \"Intent already executed\");\n\n        delete pendingWhaleIntents[msg.sender];\n        emit WhaleIntentCancelled(msg.sender, block.timestamp);\n    }\n\n    function getWhaleIntent(address trader) external view returns (\n        uint256 amount,\n        uint256 intentTime,\n        uint256 executeAfter,\n        bool isBuy,\n        bool executed,\n        bool canExecute\n    ) {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        WhaleIntent memory intent = pendingWhaleIntents[trader];\n        amount = intent.amount;\n        intentTime = intent.intentTime;\n        executeAfter = intent.intentTime + whaleConfig.whaleDelay;\n        isBuy = intent.isBuy;\n        executed = intent.executed;\n        canExecute = !intent.executed &&\n                     intent.intentTime > 0 &&\n                     block.timestamp >= intent.intentTime + whaleConfig.whaleDelay;\n    }\n\n    function getWhaleCooldown(address trader) external view returns (\n        uint256 lastTradeTime,\n        uint256 nextTradeAvailable,\n        bool canTradeNow\n    ) {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        lastTradeTime = lastWhaleTradeTime[trader];\n\n        if (lastTradeTime == 0) {\n            canTradeNow = true;\n            nextTradeAvailable = block.timestamp;\n        } else {\n            uint256 availableAt = lastTradeTime + whaleConfig.whaleDelay;\n            canTradeNow = block.timestamp >= availableAt;\n            nextTradeAvailable = canTradeNow ? block.timestamp : availableAt;\n        }\n    }\n\n    function getTradeLimits() external view returns (\n        uint256 _maxTradeSize,\n        uint256 _maxSellPercentage,\n        uint256 _whaleThreshold,\n        uint256 _whaleDelay,\n        uint256 currentMaxSellTokens\n    ) {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        return (\n            whaleConfig.maxTradeSize,\n            whaleConfig.maxSellPercentage,\n            whaleConfig.whaleThreshold,\n            whaleConfig.whaleDelay,\n            (realTokenSupply * whaleConfig.maxSellPercentage) / 10000\n        );\n    }\n\n    function getAntiBotInfo() external view returns (\n        uint256 _launchTime,\n        uint256 _timeSinceLaunch,\n        bool _antiBotActive,\n        uint256 _maxBuyEarly,\n        uint256 _cooldownPeriod,\n        uint256 _maxWalletPercentage\n    ) {\n        ICarbonCoinConfig.AntiBotConfig memory botConfig = _getAntiBotConfig();\n        return (\n            launchTime,\n            block.timestamp - launchTime,\n            block.timestamp < launchTime + botConfig.antiBotDuration,\n            botConfig.maxBuyAmountEarly,\n            botConfig.cooldownPeriod,\n            botConfig.maxWalletPercentage\n        );\n    }\n\n    function getUserCooldown(address user) external view returns (uint256) {\n        if (whitelist[user]) return 0;\n        if (lastBuyTime[user] == 0) return 0;\n        ICarbonCoinConfig.AntiBotConfig memory botConfig = _getAntiBotConfig();\n        uint256 elapsed = block.timestamp - lastBuyTime[user];\n        if (elapsed >= botConfig.cooldownPeriod) return 0;\n        return botConfig.cooldownPeriod - elapsed;\n    }\n\n    function getReserves() external view returns (\n        uint256 ethReserves,\n        uint256 tokenSupply,\n        uint256 virtualEth,\n        uint256 virtualTokens\n    ) {\n        return (realEthReserves, realTokenSupply, VIRTUAL_ETH, VIRTUAL_TOKENS);\n    }\n\n    function _owner() internal view returns (address) {\n      return Ownable(config).owner();\n    }\n\n    function _getFeeConfig() internal view returns (ICarbonCoinConfig.FeeConfig memory) {\n      return ICarbonCoinConfig(config).getFeeConfig();\n    }\n\n    function _getAntiBotConfig() internal view returns (ICarbonCoinConfig.AntiBotConfig memory) {\n      return ICarbonCoinConfig(config).getAntiBotConfig();\n    }\n\n    function _getCircuitBreakerConfig() internal view returns (ICarbonCoinConfig.CircuitBreakerConfig memory) {\n      return ICarbonCoinConfig(config).getCircuitBreakerConfig();\n    }\n\n    function _getWhaleLimitConfig() internal view returns (ICarbonCoinConfig.WhaleLimitConfig memory) {\n      return ICarbonCoinConfig(config).getWhaleLimitConfig();\n    }\n\n    modifier onlyAuthorized() {\n        if (msg.sender != launcher && msg.sender != _owner() && msg.sender != creator) revert Unauthorized();\n        _;\n    }\n\n    modifier circuitBreakerCheck() {\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n\n        // Check if circuit breaker is active\n        if (circuitBreakerTriggeredAt > 0) {\n            if (block.timestamp < circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration) {\n                revert CircuitBreakerActive();\n            } else {\n                // Reset circuit breaker\n                circuitBreakerTriggeredAt = 0;\n                emit CircuitBreakerReset(block.timestamp);\n            }\n        }\n        _;\n    }\n\n    modifier tradeSizeCheck(uint256 ethAmount, bool isBuy) {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        // Skip checks for whitelisted addresses\n        if (!whitelist[msg.sender]) {\n            // Check max trade size\n            if (isBuy && ethAmount > whaleConfig.maxTradeSize) {\n                revert TradeSizeTooLarge();\n            }\n        }\n        _;\n    }\n\n    modifier antiBotProtection(uint256 ethAmount) {\n        // Check if caller is a contract (basic check)\n        if (msg.sender != tx.origin) revert ContractCallNotAllowed();\n\n        // Check blacklist\n        if (isBlacklisted[msg.sender]) revert Blacklisted();\n\n        ICarbonCoinConfig.AntiBotConfig memory botConfig = _getAntiBotConfig();\n\n        // Early launch restrictions (first 60 seconds)\n        if (block.timestamp < launchTime + botConfig.antiBotDuration) {\n            if (ethAmount > botConfig.maxBuyAmountEarly && !whitelist[msg.sender]) {\n                revert BuyAmountTooHigh();\n            }\n        }\n\n        // Cooldown between buys (skip for whitelisted)\n        if (!whitelist[msg.sender]) {\n            if (lastBuyTime[msg.sender] != 0 &&\n                block.timestamp < lastBuyTime[msg.sender] + botConfig.cooldownPeriod) {\n                revert CooldownActive();\n            }\n        }\n\n        _;\n\n        lastBuyTime[msg.sender] = block.timestamp;\n    }\n}\n"
    },
    "contracts/CarbonCoinLauncher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// CarbonCoinLauncher.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { ICarbonCoinLauncher } from \"./interface/ICarbonCoinLauncher.sol\";\nimport { ICarbonCoinConfig } from \"./interface/ICarbonCoinConfig.sol\";\nimport { ICarbonCoin } from \"./interface/ICarbonCoin.sol\";\nimport { CarbonCoin } from \"./CarbonCoin.sol\";\n\n\n/**\n * @title CarbonCoinLauncher\n * @author CarbonOpus\n * @notice This contract is responsible for creating and managing CarbonCoin tokens.\n * It allows users to create their own tokens for a fee, and it keeps track of all the tokens created.\n * The owner of the contract can manage the creation fee, the maximum number of tokens per creator, and can pause or unpause the contract.\n * The contract also includes functions for withdrawing fees and transferring ownership.\n */\ncontract CarbonCoinLauncher is ICarbonCoinLauncher, ReentrancyGuard, Pausable, Ownable {\n  /// @notice The address of the CarbonCoinConfig contract, which provides default configurations for new tokens.\n  address public configAddress;\n  /// @notice The address of the DEX router, which is used for creating liquidity pairs.\n  address public immutable dexRouter;\n  /// @notice The fee for creating a new token.\n  uint256 public creationFee = 0.0001 ether;\n  /// @notice The maximum number of tokens that a single address can create.\n  uint256 public maxTokensPerCreator = 1;\n\n  /// @notice A mapping from a token address to its TokenInfo struct.\n  mapping(address => TokenInfo) public tokens;\n  /// @notice A mapping from a creator's address to the number of tokens they have created.\n  mapping(address => uint256) public tokensCreatedByAddress;\n  /// @notice A mapping from a creator's address to an array of token addresses they have created.\n  // mapping(address => address[]) public tokensByCreator;\n  /// @notice An array of all the token addresses that have been created.\n  // address[] public allTokens;\n\n  // Revenue tracking\n  /// @notice The total amount of fees collected from token creations.\n  uint256 public totalFeesCollected;\n  /// @notice The total number of tokens that have been created.\n  uint256 public totalTokensCreated;\n\n  /**\n   * @notice The constructor for the CarbonCoinLauncher contract.\n   * @param _dexRouter The address of the DEX router.\n   */\n  constructor(address _configAddress, address _dexRouter) Ownable() ReentrancyGuard() Pausable() {\n    if (_configAddress == address(0) || _dexRouter == address(0)) revert InvalidParameters();\n    configAddress = _configAddress;\n    dexRouter = _dexRouter;\n  }\n\n  /**\n   * @notice Creates a new CarbonCoin token.\n   * @param name The name of the token.\n   * @param symbol The symbol of the token.\n   * @return The address of the newly created token.\n   */\n    function createToken(\n      string memory name,\n      string memory symbol,\n      ICarbonCoin.BondingCurveConfig memory curveConfig\n    ) public payable nonReentrant whenNotPaused returns (address) {\n      if (msg.value < creationFee) revert InsufficientFee();\n      if (bytes(name).length == 0 || bytes(symbol).length == 0) revert InvalidParameters();\n      if (tokensCreatedByAddress[msg.sender] >= maxTokensPerCreator) revert TooManyTokens();\n\n      CarbonCoin token = new CarbonCoin(\n        name,\n        symbol,\n        msg.sender, // Creator\n        dexRouter,\n        configAddress,\n        curveConfig\n      );\n\n      address tokenAddress = address(token);\n\n      tokens[tokenAddress] = TokenInfo({\n        tokenAddress: tokenAddress,\n        creator: msg.sender,\n        createdAt: block.timestamp,\n        graduated: false,\n        name: name,\n        symbol: symbol\n      });\n\n      // allTokens.push(tokenAddress);\n      // tokensByCreator[msg.sender].push(tokenAddress);\n      tokensCreatedByAddress[msg.sender]++;\n\n      totalFeesCollected += msg.value;\n      totalTokensCreated++;\n\n      emit TokenCreated(\n        tokenAddress,\n        msg.sender,\n        name,\n        symbol,\n        block.timestamp,\n        creationFee\n      );\n\n      // Refund excess ETH\n      if (msg.value > creationFee) {\n        (bool success, ) = payable(msg.sender).call{value: msg.value - creationFee}(\"\");\n        require(success, \"Refund failed\");\n      }\n\n      return tokenAddress;\n    }\n\n  /**\n   * @notice Gets an array of all the token addresses that have been created.\n   * @return An array of token addresses.\n   */\n  // function getAllTokens() external view returns (address[] memory) {\n  //   return allTokens;\n  // }\n\n  /**\n   * @notice Gets an array of all the token addresses that have been created by a specific creator.\n   * @param creator The address of the creator.\n   * @return An array of token addresses.\n   */\n  // function getTokensByCreator(address creator) external view returns (address[] memory) {\n  //   return tokensByCreator[creator];\n  // }\n\n  /**\n   * @notice Gets the TokenInfo struct for a specific token.\n   * @param tokenAddress The address of the token.\n   * @return The TokenInfo struct for the token.\n   */\n  // function getTokenInfo(address tokenAddress) external view returns (TokenInfo memory) {\n  //   return tokens[tokenAddress];\n  // }\n\n  /**\n   * @notice Gets the total number of tokens that have been created.\n   * @return The total number of tokens.\n   */\n  // function getTokenCount() external view returns (uint256) {\n  //   return allTokens.length;\n  // }\n\n  /**\n   * @notice Gets an array of the most recently created tokens.\n   * @param count The number of recent tokens to get.\n   * @return An array of token addresses.\n   */\n  // function getRecentTokens(uint256 count) external view returns (address[] memory) {\n  //   uint256 total = allTokens.length;\n  //   uint256 returnCount = count > total ? total : count;\n  //   address[] memory recent = new address[](returnCount);\n\n  //   for (uint256 i = 0; i < returnCount; i++) {\n  //     recent[i] = allTokens[total - 1 - i];\n  //   }\n\n  //   return recent;\n  // }\n\n  // Admin functions\n  /**\n   * @notice Sets the fee for creating a new token.\n   * @param _fee The new creation fee.\n   */\n  function setCreationFee(uint256 _fee) external onlyOwner {\n    require(_fee <= 0.1 ether, \"Fee too high\");\n    uint256 oldFee = creationFee;\n    creationFee = _fee;\n    emit CreationFeeUpdated(oldFee, _fee, block.timestamp);\n  }\n\n  /**\n   * @notice Sets the maximum number of tokens that a single address can create.\n   * @param _max The new maximum number of tokens.\n   */\n  function setMaxTokensPerCreator(uint256 _max) external onlyOwner {\n    require(_max > 0 && _max <= 100, \"Invalid max\");\n    uint256 oldMax = maxTokensPerCreator;\n    maxTokensPerCreator = _max;\n    emit MaxTokensPerCreatorUpdated(oldMax, _max, block.timestamp);\n  }\n\n  /**\n   * @notice Pauses the contract, which prevents new tokens from being created.\n   */\n  function pause() external onlyOwner {\n    _pause();\n    emit LauncherPaused(block.timestamp);\n  }\n\n  /**\n   * @notice Unpauses the contract, which allows new tokens to be created again.\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n    emit LauncherUnpaused(block.timestamp);\n  }\n\n  /**\n   * @notice Withdraws the fees that have been collected from token creations.\n   */\n  function withdraw() external onlyOwner {\n    uint256 balance = address(this).balance;\n    (bool success, ) = payable(owner()).call{value: balance}(\"\");\n    require(success, \"Withdrawal failed\");\n    emit FeesWithdrawn(owner(), balance, block.timestamp);\n  }\n\n  /**\n   * @notice Marks a token as graduated. This can be called by the token contract itself or by the owner of the launcher contract.\n   * @param tokenAddress The address of the token to mark as graduated.\n   */\n  function markTokenGraduated(address tokenAddress) external {\n    require(\n      msg.sender == tokenAddress || msg.sender == owner(),\n      \"Only token or owner can mark graduated\"\n    );\n    if (tokens[tokenAddress].tokenAddress != address(0)) {\n      tokens[tokenAddress].graduated = true;\n\n      CarbonCoin token = CarbonCoin(payable(tokenAddress));\n      address pair = token.dexPair();\n\n      emit TokenGraduated(tokenAddress, pair, block.timestamp);\n    }\n  }\n\n  /**\n   * @notice Gets statistics about the contract.\n   * @return _totalTokensCreated The total number of tokens created.\n   * @return _totalFeesCollected The total fees collected.\n   * @return _creationFee The current creation fee.\n   */\n  function getStats() external view returns (\n    uint256 _totalTokensCreated,\n    uint256 _totalFeesCollected,\n    uint256 _creationFee\n  ) {\n    return (totalTokensCreated, totalFeesCollected, creationFee);\n  }\n}"
    },
    "contracts/interface/ICarbonCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ICarbonCoin.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\ninterface ICarbonCoin {\n  struct BondingCurveConfig {\n    uint256 virtualEth;\n    uint256 virtualTokens;\n    uint256 maxSupply;\n    uint256 graduationThreshold;\n  }\n\n  struct PriceSnapshot {\n    uint256 price;\n    uint256 timestamp;\n  }\n\n  struct WhaleIntent {\n    uint256 amount;\n    uint256 intentTime;\n    bool isBuy;\n    bool executed;\n  }\n\n  // Trading events\n  event TokensPurchased(\n    address indexed buyer,\n    uint256 ethIn,\n    uint256 tokensOut,\n    uint256 newPrice,\n    uint256 realEthReserves,\n    uint256 realTokenSupply,\n    uint256 timestamp\n  );\n  event TokensSold(\n    address indexed seller,\n    uint256 tokensIn,\n    uint256 ethOut,\n    uint256 newPrice,\n    uint256 realEthReserves,\n    uint256 realTokenSupply,\n    uint256 timestamp\n  );\n\n  // Lifecycle events\n  event TokenDeployed(\n    address indexed token,\n    address indexed creator,\n    string name,\n    string symbol,\n    uint256 maxSupply,\n    uint256 graduationThreshold,\n    uint256 timestamp\n  );\n  event Graduated(\n    address indexed token,\n    address indexed pair,\n    uint256 liquidityTokens,\n    uint256 liquidityEth,\n    uint256 finalPrice,\n    uint256 timestamp\n  );\n\n  // Admin events\n  event BotDetected(address indexed suspect, string reason, uint256 timestamp);\n  event AddressBlacklisted(address indexed account, bool blacklisted, uint256 timestamp);\n  event AddressWhitelisted(address indexed account, bool whitelisted, uint256 timestamp);\n  event EmergencyWithdraw(address indexed to, uint256 amount, uint256 timestamp);\n  event TradingPaused(uint256 timestamp);\n  event TradingUnpaused(uint256 timestamp);\n\n  // Circuit breaker events\n  event CircuitBreakerTriggered(string reason, uint256 timestamp, uint256 duration);\n  event CircuitBreakerReset(uint256 timestamp);\n  event HighPriceImpact(address indexed trader, uint256 priceImpact, uint256 timestamp);\n  event VolatilityWarning(uint256 moveCount, uint256 timestamp);\n\n  // Whale protection events\n  event WhaleIntentRegistered(address indexed trader, uint256 amount, bool isBuy, uint256 executeAfter, uint256 timestamp);\n  event WhaleIntentCancelled(address indexed trader, uint256 timestamp);\n  event WhaleTradeExecuted(address indexed trader, uint256 amount, bool isBuy, uint256 timestamp);\n\n  // State tracking events\n  event PriceUpdate(uint256 price, uint256 ethReserves, uint256 tokenSupply, uint256 timestamp);\n  event LiquiditySnapshot(uint256 ethReserves, uint256 tokenSupply, uint256 timestamp);\n\n  error Unauthorized();\n  error InvalidAmount();\n  error ExceedsMaxSupply();\n  error SlippageTooHigh();\n  error InsufficientLiquidity();\n  error AlreadyGraduated();\n  error NotGraduated();\n  error CooldownActive();\n  error ExceedsMaxWallet();\n  error Blacklisted();\n  error ContractCallNotAllowed();\n  error BuyAmountTooHigh();\n  error FeeExceedsMaximum();\n  error GraduationCooldownActive();\n  error CircuitBreakerActive();\n  error PriceImpactTooHigh();\n  error ExcessiveVolatility();\n  error TradeSizeTooLarge();\n  error WhaleDelayActive();\n  error WhaleIntentRequired();\n  error WhaleIntentNotReady();\n  error NoWhaleIntentFound();\n  error SellAmountTooLarge();\n\n  function getCurrentPrice() external view returns (uint256);\n\n  function calculateTokensOut(uint256 ethIn) external view returns (uint256);\n\n  function calculateEthIn(uint256 tokensOut) external view returns (uint256);\n\n  function calculateEthOut(uint256 tokensIn) external view returns (uint256);\n\n  function buy(uint256 minTokensOut) external payable;\n\n  function sell(uint256 tokensIn, uint256 minEthOut) external;\n\n  function forceGraduate() external;\n\n  function blacklistAddress(address account, bool blacklisted) external;\n\n  function addToWhitelist(address account) external;\n\n  function removeFromWhitelist(address account) external;\n\n  function pause() external;\n\n  function unpause() external;\n\n  function emergencyWithdraw() external;\n\n  function triggerCircuitBreaker(string memory reason) external;\n\n  function resetCircuitBreaker() external;\n\n  function getCircuitBreakerStatus() external view returns (\n    bool isActive,\n    uint256 triggeredAt,\n    uint256 timeRemaining,\n    uint256 volatilityMoves\n  );\n\n  function cancelWhaleIntent() external;\n\n  function getWhaleIntent(address trader) external view returns (\n    uint256 amount,\n    uint256 intentTime,\n    uint256 executeAfter,\n    bool isBuy,\n    bool executed,\n    bool canExecute\n  );\n\n  function getWhaleCooldown(address trader) external view returns (\n    uint256 lastTradeTime,\n    uint256 nextTradeAvailable,\n    bool canTradeNow\n  );\n\n  function getTradeLimits() external view returns (\n    uint256 _maxTradeSize,\n    uint256 _maxSellPercentage,\n    uint256 _whaleThreshold,\n    uint256 _whaleDelay,\n    uint256 currentMaxSellTokens\n  );\n\n  function getAntiBotInfo() external view returns (\n    uint256 _launchTime,\n    uint256 _timeSinceLaunch,\n    bool _antiBotActive,\n    uint256 _maxBuyEarly,\n    uint256 _cooldownPeriod,\n    uint256 _maxWalletPercentage\n  );\n\n  function getUserCooldown(address user) external view returns (uint256);\n\n  function getReserves() external view returns (\n    uint256 ethReserves,\n    uint256 tokenSupply,\n    uint256 virtualEth,\n    uint256 virtualTokens\n  );\n}\n"
    },
    "contracts/interface/ICarbonCoinConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ICarbonCoinConfig.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\nimport { ICarbonCoin } from \"./ICarbonCoin.sol\";\n\ninterface ICarbonCoinConfig {\n  struct FeeConfig {\n    uint256 buyFee;\n    uint256 sellFee;\n    uint256 maxFee;\n  }\n\n  struct AntiBotConfig {\n    uint256 antiBotDuration;\n    uint256 maxBuyAmountEarly;\n    uint256 maxWalletPercentage;\n    uint256 cooldownPeriod;\n    uint256 minBuyAmount;\n  }\n\n  struct CircuitBreakerConfig {\n    uint256 maxPriceImpact;\n    uint256 volatilityWindow;\n    uint256 maxVolatilityMoves;\n    uint256 circuitBreakerDuration;\n  }\n\n  struct WhaleLimitConfig {\n    uint256 whaleThreshold;\n    uint256 whaleDelay;\n    uint256 maxTradeSize;\n    uint256 maxSellPercentage;\n  }\n\n  event DefaultConfigUpdated(string configType, uint256 timestamp);\n\n  function updateDefaultFeeConfig(FeeConfig memory newConfig) external;\n\n  function updateDefaultAntiBotConfig(AntiBotConfig memory newConfig) external;\n\n  function updateDefaultCircuitBreakerConfig(CircuitBreakerConfig memory newConfig) external;\n\n  function updateDefaultWhaleLimitConfig(WhaleLimitConfig memory newConfig) external;\n\n  function getFeeConfig() external view returns (FeeConfig memory);\n  function getAntiBotConfig() external view returns (AntiBotConfig memory);\n  function getCircuitBreakerConfig() external view returns (CircuitBreakerConfig memory);\n  function getWhaleLimitConfig() external view returns (WhaleLimitConfig memory);\n\n}\n"
    },
    "contracts/interface/ICarbonCoinLauncher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ICarbonCoinLauncher.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\nimport { ICarbonCoin } from \"./ICarbonCoin.sol\";\n\ninterface ICarbonCoinLauncher {\n  struct TokenInfo {\n    address tokenAddress;\n    address creator;\n    uint256 createdAt;\n    bool graduated;\n    string name;\n    string symbol;\n  }\n\n  event TokenCreated(\n    address indexed tokenAddress,\n    address indexed creator,\n    string name,\n    string symbol,\n    uint256 timestamp,\n    uint256 creationFee\n  );\n  event TokenGraduated(\n    address indexed tokenAddress,\n    address indexed dexPair,\n    uint256 timestamp\n  );\n  event CreationFeeUpdated(uint256 oldFee, uint256 newFee, uint256 timestamp);\n  event MaxTokensPerCreatorUpdated(uint256 oldMax, uint256 newMax, uint256 timestamp);\n  event LauncherPaused(uint256 timestamp);\n  event LauncherUnpaused(uint256 timestamp);\n  event FeesWithdrawn(address indexed to, uint256 amount, uint256 timestamp);\n\n  error Unauthorized();\n  error InsufficientFee();\n  error TooManyTokens();\n  error InvalidParameters();\n\n  function createToken(\n    string memory name,\n    string memory symbol,\n    ICarbonCoin.BondingCurveConfig memory curveConfig\n  ) external payable returns (address);\n\n  // function getAllTokens() external view returns (address[] memory);\n\n  // function getTokensByCreator(address creator) external view returns (address[] memory);\n\n  // function getTokenInfo(address tokenAddress) external view returns (TokenInfo memory);\n\n  // function getTokenCount() external view returns (uint256);\n\n  // function getRecentTokens(uint256 count) external view returns (address[] memory);\n\n  function setCreationFee(uint256 _fee) external;\n\n  function setMaxTokensPerCreator(uint256 _max) external;\n\n  function withdraw() external;\n\n  function markTokenGraduated(address tokenAddress) external;\n\n  function getStats() external view returns (\n    uint256 _totalTokensCreated,\n    uint256 _totalFeesCollected,\n    uint256 _creationFee\n  );\n}\n"
    },
    "contracts/interface/ISomniaExchangeRouter02.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\ninterface ISomniaExchangeRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface ISomniaExchangeRouter02 is ISomniaExchangeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}