{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/CarbonCoinProtection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// CarbonCoinProtection.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICarbonCoinConfig } from \"./interface/ICarbonCoinConfig.sol\";\nimport { ICarbonCoinProtection } from \"./interface/ICarbonCoinProtection.sol\";\n\n/**\n * @title CarbonCoinProtection\n * @notice Centralized protection mechanism for all CarbonCoin tokens\n * @dev Handles anti-bot, whale limits, circuit breakers for multiple tokens\n */\ncontract CarbonCoinProtection is ICarbonCoinProtection, Ownable {\n    // Token address => Protection state\n    mapping(address => TokenProtectionState) public tokenStates;\n\n    // Token => User => Last buy time\n    mapping(address => mapping(address => uint256)) public lastBuyTime;\n\n    // Token => User => Last whale trade time\n    mapping(address => mapping(address => uint256)) public lastWhaleTradeTime;\n\n    // Token => User => Whale intent\n    mapping(address => mapping(address => WhaleIntent)) public pendingWhaleIntents;\n\n    // Token => User => Blacklisted\n    mapping(address => mapping(address => bool)) public isBlacklisted;\n\n    // Token => User => Whitelisted\n    mapping(address => mapping(address => bool)) public whitelist;\n\n    address public immutable config;\n\n    constructor(address _config) Ownable(msg.sender) {\n        require(_config != address(0), \"Invalid config\");\n        config = _config;\n    }\n\n    /**\n     * @notice Initialize protection for a new token\n     */\n    function initializeToken(address token, address creator, address launcher) external onlyOwner {\n        TokenProtectionState storage state = tokenStates[token];\n        state.launchTime = block.timestamp;\n\n        // Whitelist creator and launcher\n        whitelist[token][creator] = true;\n        whitelist[token][launcher] = true;\n    }\n\n    /**\n     * @notice Check if anti-bot protection should be applied\n     */\n    function checkAntiBotProtection(\n        address token,\n        address user,\n        uint256 amount,\n        bool isBuy\n    ) external {\n        require(msg.sender == token, \"Only token can call\");\n        require(tx.origin == user, \"Contract call not allowed\");\n        require(!isBlacklisted[token][user], \"Blacklisted\");\n\n        if (!isBuy) return; // Only apply to buys\n\n        ICarbonCoinConfig.AntiBotConfig memory botConfig = _getAntiBotConfig();\n        TokenProtectionState storage state = tokenStates[token];\n\n        // Check early buy limits\n        if (block.timestamp < state.launchTime + botConfig.antiBotDuration) {\n            require(amount <= botConfig.maxBuyAmountEarly || whitelist[token][user], \"Buy amount too high\");\n        }\n\n        // Check cooldown\n        if (!whitelist[token][user]) {\n            if (lastBuyTime[token][user] != 0) {\n                require(block.timestamp >= lastBuyTime[token][user] + botConfig.cooldownPeriod, \"Cooldown active\");\n            }\n        }\n\n        lastBuyTime[token][user] = block.timestamp;\n    }\n\n    /**\n     * @notice Check circuit breaker status\n     */\n    function checkCircuitBreaker(address token) external view {\n        require(msg.sender == token, \"Only token can call\");\n\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        TokenProtectionState storage state = tokenStates[token];\n\n        if (state.circuitBreakerTriggeredAt > 0) {\n            if (block.timestamp < state.circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration) {\n                revert CircuitBreakerActive();\n            }\n        }\n    }\n\n    /**\n     * @notice Reset circuit breaker if expired\n     */\n    function resetCircuitBreakerIfExpired(address token) external {\n        require(msg.sender == token, \"Only token can call\");\n\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        TokenProtectionState storage state = tokenStates[token];\n\n        if (state.circuitBreakerTriggeredAt > 0) {\n            if (block.timestamp >= state.circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration) {\n                state.circuitBreakerTriggeredAt = 0;\n                emit CircuitBreakerReset(token, block.timestamp);\n            }\n        }\n    }\n\n    /**\n     * @notice Check trade size limits\n     */\n    function checkTradeSizeLimit(address token, address user, uint256 amount) external view {\n        require(msg.sender == token, \"Only token can call\");\n\n        if (whitelist[token][user]) return;\n\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        require(amount <= whaleConfig.maxTradeSize, \"Trade size too large\");\n    }\n\n    /**\n     * @notice Check if whale intent is required and handle it\n     * @return requiresIntent Whether a whale intent is required\n     * @return canProceed Whether the trade can proceed\n     */\n    function checkWhaleIntent(\n        address token,\n        address user,\n        uint256 amount,\n        bool isBuy\n    ) external returns (bool requiresIntent, bool canProceed) {\n        require(msg.sender == token, \"Only token can call\");\n\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n\n        // Not a whale trade if whitelisted or below threshold\n        if (whitelist[token][user] || amount < whaleConfig.whaleThreshold) {\n            return (false, true);\n        }\n\n        // Check cooldown\n        if (lastWhaleTradeTime[token][user] > 0) {\n            if (block.timestamp < lastWhaleTradeTime[token][user] + whaleConfig.whaleDelay) {\n                revert WhaleDelayActive();\n            }\n        }\n\n        WhaleIntent storage intent = pendingWhaleIntents[token][user];\n\n        // No intent exists\n        if (intent.intentTime == 0) {\n            intent.amount = amount;\n            intent.intentTime = block.timestamp;\n            intent.isBuy = isBuy;\n            intent.executed = false;\n\n            emit WhaleIntentRegistered(\n                token,\n                user,\n                amount,\n                isBuy,\n                block.timestamp + whaleConfig.whaleDelay,\n                block.timestamp\n            );\n\n            return (true, false);\n        }\n\n        // Intent exists but not ready\n        if (block.timestamp < intent.intentTime + whaleConfig.whaleDelay) {\n            revert WhaleIntentNotReady();\n        }\n\n        // Verify intent\n        require(intent.isBuy == isBuy, \"Intent type mismatch\");\n        require(!intent.executed, \"Intent already executed\");\n        require(intent.amount == amount, \"Amount must match intent\");\n\n        // Mark as executed\n        intent.executed = true;\n        lastWhaleTradeTime[token][user] = block.timestamp;\n\n        emit WhaleTradeExecuted(token, user, amount, isBuy, block.timestamp);\n\n        // Clean up\n        delete pendingWhaleIntents[token][user];\n\n        return (true, true);\n    }\n\n    /**\n     * @notice Track price volatility and trigger circuit breaker if needed\n     */\n    function trackVolatility(\n        address token,\n        uint256 currentPrice,\n        uint256 /* priceBefore */\n    ) external {\n        require(msg.sender == token, \"Only token can call\");\n\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        TokenProtectionState storage state = tokenStates[token];\n\n        // Reset counter if window expired\n        if (block.timestamp > state.lastVolatilityReset + cbConfig.volatilityWindow) {\n            state.volatilityMoveCount = 0;\n            state.lastVolatilityReset = block.timestamp;\n            delete state.recentPrices;\n        }\n\n        // Record price snapshot\n        state.recentPrices.push(PriceSnapshot({\n            price: currentPrice,\n            timestamp: block.timestamp\n        }));\n\n        uint256 pricesLength = state.recentPrices.length;\n\n        // Check for significant price moves\n        if (pricesLength > 1) {\n            uint256 lastPrice = state.recentPrices[pricesLength - 2].price;\n            uint256 priceChange = currentPrice > lastPrice\n                ? ((currentPrice - lastPrice) * 10000) / lastPrice\n                : ((lastPrice - currentPrice) * 10000) / lastPrice;\n\n            // Count moves greater than 5%\n            if (priceChange > 500) {\n                state.volatilityMoveCount++;\n\n                if (state.volatilityMoveCount >= cbConfig.maxVolatilityMoves) {\n                    emit VolatilityWarning(token, state.volatilityMoveCount, block.timestamp);\n                    _triggerCircuitBreaker(token, \"Excessive volatility detected\");\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Check price impact and trigger circuit breaker if excessive\n     */\n    function checkPriceImpact(\n        address token,\n        address user,\n        uint256 priceBefore,\n        uint256 priceAfter,\n        uint256 tradeSize,\n        bool isBuy\n    ) external {\n        require(msg.sender == token, \"Only token can call\");\n\n        if (whitelist[token][user]) return;\n\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n\n        // Only check for significant trades (1000+ USDC)\n        if (tradeSize < 1000 * 10**6) return;\n\n        uint256 priceImpact;\n        if (isBuy) {\n            priceImpact = ((priceAfter - priceBefore) * 10000) / priceBefore;\n        } else {\n            priceImpact = ((priceBefore - priceAfter) * 10000) / priceBefore;\n        }\n\n        if (priceImpact > cbConfig.maxPriceImpact) {\n            emit HighPriceImpact(token, user, priceImpact, block.timestamp);\n\n            // Trigger circuit breaker for extreme impact\n            if (priceImpact > cbConfig.maxPriceImpact * 2) {\n                _triggerCircuitBreaker(token, \"Excessive price impact\");\n                revert PriceImpactTooHigh();\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to trigger circuit breaker\n     */\n    function _triggerCircuitBreaker(address token, string memory reason) internal {\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        TokenProtectionState storage state = tokenStates[token];\n\n        state.circuitBreakerTriggeredAt = block.timestamp;\n        emit CircuitBreakerTriggered(token, reason, block.timestamp, cbConfig.circuitBreakerDuration);\n    }\n\n    // Admin functions\n    function blacklistAddress(address token, address user, bool blacklisted) external onlyOwner {\n        isBlacklisted[token][user] = blacklisted;\n        emit AddressBlacklisted(token, user, blacklisted, block.timestamp);\n        if (blacklisted) {\n            emit BotDetected(token, user, \"Manually blacklisted\", block.timestamp);\n        }\n    }\n\n    function addToWhitelist(address token, address user) external onlyOwner {\n        whitelist[token][user] = true;\n        emit AddressWhitelisted(token, user, true, block.timestamp);\n    }\n\n    function removeFromWhitelist(address token, address user) external onlyOwner {\n        whitelist[token][user] = false;\n        emit AddressWhitelisted(token, user, false, block.timestamp);\n    }\n\n    function triggerCircuitBreaker(address token, string memory reason) external onlyOwner {\n        _triggerCircuitBreaker(token, reason);\n    }\n\n    function resetCircuitBreaker(address token) external onlyOwner {\n        TokenProtectionState storage state = tokenStates[token];\n        state.circuitBreakerTriggeredAt = 0;\n        state.volatilityMoveCount = 0;\n        state.lastVolatilityReset = block.timestamp;\n        delete state.recentPrices;\n        emit CircuitBreakerReset(token, block.timestamp);\n    }\n\n    function cancelWhaleIntent(address token, address user) external {\n        require(msg.sender == user || msg.sender == owner(), \"Unauthorized\");\n\n        WhaleIntent storage intent = pendingWhaleIntents[token][user];\n        if (intent.intentTime == 0) revert NoWhaleIntentFound();\n        require(!intent.executed, \"Intent already executed\");\n\n        delete pendingWhaleIntents[token][user];\n        emit WhaleIntentCancelled(token, user, block.timestamp);\n    }\n\n    // View functions\n    function getCircuitBreakerStatus(address token) external view returns (\n        bool isActive,\n        uint256 triggeredAt,\n        uint256 timeRemaining,\n        uint256 volatilityMoves\n    ) {\n        ICarbonCoinConfig.CircuitBreakerConfig memory cbConfig = _getCircuitBreakerConfig();\n        TokenProtectionState storage state = tokenStates[token];\n\n        isActive = state.circuitBreakerTriggeredAt > 0 &&\n                   block.timestamp < state.circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration;\n        triggeredAt = state.circuitBreakerTriggeredAt;\n\n        if (isActive) {\n            timeRemaining = (state.circuitBreakerTriggeredAt + cbConfig.circuitBreakerDuration) - block.timestamp;\n        } else {\n            timeRemaining = 0;\n        }\n\n        volatilityMoves = state.volatilityMoveCount;\n    }\n\n    function getWhaleIntent(address token, address trader) external view returns (\n        uint256 amount,\n        uint256 intentTime,\n        uint256 executeAfter,\n        bool isBuy,\n        bool executed,\n        bool canExecute\n    ) {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        WhaleIntent memory intent = pendingWhaleIntents[token][trader];\n\n        amount = intent.amount;\n        intentTime = intent.intentTime;\n        executeAfter = intent.intentTime + whaleConfig.whaleDelay;\n        isBuy = intent.isBuy;\n        executed = intent.executed;\n        canExecute = !intent.executed &&\n                     intent.intentTime > 0 &&\n                     block.timestamp >= intent.intentTime + whaleConfig.whaleDelay;\n    }\n\n    function getWhaleCooldown(address token, address trader) external view returns (\n        uint256 lastTradeTime,\n        uint256 nextTradeAvailable,\n        bool canTradeNow\n    ) {\n        ICarbonCoinConfig.WhaleLimitConfig memory whaleConfig = _getWhaleLimitConfig();\n        lastTradeTime = lastWhaleTradeTime[token][trader];\n\n        if (lastTradeTime == 0) {\n            canTradeNow = true;\n            nextTradeAvailable = block.timestamp;\n        } else {\n            uint256 availableAt = lastTradeTime + whaleConfig.whaleDelay;\n            canTradeNow = block.timestamp >= availableAt;\n            nextTradeAvailable = canTradeNow ? block.timestamp : availableAt;\n        }\n    }\n\n    function getUserCooldown(address token, address user) external view returns (uint256) {\n        if (whitelist[token][user]) return 0;\n        if (lastBuyTime[token][user] == 0) return 0;\n\n        ICarbonCoinConfig.AntiBotConfig memory botConfig = _getAntiBotConfig();\n        uint256 elapsed = block.timestamp - lastBuyTime[token][user];\n\n        if (elapsed >= botConfig.cooldownPeriod) return 0;\n        return botConfig.cooldownPeriod - elapsed;\n    }\n\n    // Internal helper functions\n    function _getAntiBotConfig() internal view returns (ICarbonCoinConfig.AntiBotConfig memory) {\n        return ICarbonCoinConfig(config).getAntiBotConfig();\n    }\n\n    function _getCircuitBreakerConfig() internal view returns (ICarbonCoinConfig.CircuitBreakerConfig memory) {\n        return ICarbonCoinConfig(config).getCircuitBreakerConfig();\n    }\n\n    function _getWhaleLimitConfig() internal view returns (ICarbonCoinConfig.WhaleLimitConfig memory) {\n        return ICarbonCoinConfig(config).getWhaleLimitConfig();\n    }\n}\n"
    },
    "contracts/interface/ICarbonCoinConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ICarbonCoinConfig.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\ninterface ICarbonCoinConfig {\n  struct FeeConfig {\n    uint256 buyFee;\n    uint256 sellFee;\n    uint256 maxFee;\n  }\n\n  struct AntiBotConfig {\n    uint256 antiBotDuration;\n    uint256 maxBuyAmountEarly;\n    uint256 maxWalletPercentage;\n    uint256 cooldownPeriod;\n    uint256 minBuyAmount;\n  }\n\n  struct CircuitBreakerConfig {\n    uint256 maxPriceImpact;\n    uint256 volatilityWindow;\n    uint256 maxVolatilityMoves;\n    uint256 circuitBreakerDuration;\n  }\n\n  struct WhaleLimitConfig {\n    uint256 whaleThreshold;\n    uint256 whaleDelay;\n    uint256 maxTradeSize;\n    uint256 maxSellPercentage;\n  }\n\n  event DefaultConfigUpdated(string configType, uint256 timestamp);\n\n  function updateDefaultFeeConfig(FeeConfig memory newConfig) external;\n  function updateDefaultAntiBotConfig(AntiBotConfig memory newConfig) external;\n  function updateDefaultCircuitBreakerConfig(CircuitBreakerConfig memory newConfig) external;\n  function updateDefaultWhaleLimitConfig(WhaleLimitConfig memory newConfig) external;\n\n  function getCarbonCoinDex() external view returns (address);\n  function getFeeConfig() external view returns (FeeConfig memory);\n  function getAntiBotConfig() external view returns (AntiBotConfig memory);\n  function getCircuitBreakerConfig() external view returns (CircuitBreakerConfig memory);\n  function getWhaleLimitConfig() external view returns (WhaleLimitConfig memory);\n\n}\n"
    },
    "contracts/interface/ICarbonCoinProtection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ICarbonCoinProtection.sol\n// Copyright (c) 2025 CarbonOpus\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\npragma solidity 0.8.27;\n\ninterface ICarbonCoinProtection {\n    struct PriceSnapshot {\n        uint256 price;\n        uint256 timestamp;\n    }\n\n    struct WhaleIntent {\n        uint256 amount;\n        uint256 intentTime;\n        bool isBuy;\n        bool executed;\n    }\n\n    struct TokenProtectionState {\n        uint256 launchTime;\n        uint256 circuitBreakerTriggeredAt;\n        uint256 volatilityMoveCount;\n        uint256 lastVolatilityReset;\n        PriceSnapshot[] recentPrices;\n    }\n\n    // Events\n    event BotDetected(address indexed token, address indexed user, string reason, uint256 timestamp);\n    event AddressBlacklisted(address indexed token, address indexed user, bool blacklisted, uint256 timestamp);\n    event AddressWhitelisted(address indexed token, address indexed user, bool whitelisted, uint256 timestamp);\n    event CircuitBreakerTriggered(address indexed token, string reason, uint256 timestamp, uint256 duration);\n    event CircuitBreakerReset(address indexed token, uint256 timestamp);\n    event VolatilityWarning(address indexed token, uint256 moveCount, uint256 timestamp);\n    event HighPriceImpact(address indexed token, address indexed trader, uint256 impact, uint256 timestamp);\n    event WhaleIntentRegistered(address indexed token, address indexed trader, uint256 amount, bool isBuy, uint256 executeAfter, uint256 timestamp);\n    event WhaleTradeExecuted(address indexed token, address indexed trader, uint256 amount, bool isBuy, uint256 timestamp);\n    event WhaleIntentCancelled(address indexed token, address indexed trader, uint256 timestamp);\n\n    // Custom errors\n    error WhaleDelayActive();\n    error WhaleIntentRequired();\n    error WhaleIntentNotReady();\n    error NoWhaleIntentFound();\n    error CircuitBreakerActive();\n    error PriceImpactTooHigh();\n    error Unauthorized();\n\n    /**\n     * @notice Initialize protection for a new token\n     */\n    function initializeToken(address token, address creator, address launcher) external;\n\n    /**\n     * @notice Check if anti-bot protection should be applied\n     */\n    function checkAntiBotProtection(\n        address token,\n        address user,\n        uint256 amount,\n        bool isBuy\n    ) external;\n\n    /**\n     * @notice Check circuit breaker status\n     */\n    function checkCircuitBreaker(address token) external view;\n\n    /**\n     * @notice Reset circuit breaker if expired\n     */\n    function resetCircuitBreakerIfExpired(address token) external;\n\n    /**\n     * @notice Check trade size limits\n     */\n    function checkTradeSizeLimit(address token, address user, uint256 amount) external view;\n\n    /**\n     * @notice Check if whale intent is required and handle it\n     * @return requiresIntent Whether a whale intent is required\n     * @return canProceed Whether the trade can proceed\n     */\n    function checkWhaleIntent(\n        address token,\n        address user,\n        uint256 amount,\n        bool isBuy\n    ) external returns (bool requiresIntent, bool canProceed);\n\n    /**\n     * @notice Track price volatility and trigger circuit breaker if needed\n     */\n    function trackVolatility(\n        address token,\n        uint256 currentPrice,\n        uint256 priceBefore\n    ) external;\n\n    /**\n     * @notice Check price impact and trigger circuit breaker if excessive\n     */\n    function checkPriceImpact(\n        address token,\n        address user,\n        uint256 priceBefore,\n        uint256 priceAfter,\n        uint256 tradeSize,\n        bool isBuy\n    ) external;\n\n    function cancelWhaleIntent(address token, address user) external;\n\n    // View functions\n    function getCircuitBreakerStatus(address token) external view returns (\n        bool isActive,\n        uint256 triggeredAt,\n        uint256 timeRemaining,\n        uint256 volatilityMoves\n    );\n\n    function getWhaleIntent(address token, address trader) external view returns (\n        uint256 amount,\n        uint256 intentTime,\n        uint256 executeAfter,\n        bool isBuy,\n        bool executed,\n        bool canExecute\n    );\n\n    function getWhaleCooldown(address token, address trader) external view returns (\n        uint256 lastTradeTime,\n        uint256 nextTradeAvailable,\n        bool canTradeNow\n    );\n\n    function getUserCooldown(address token, address user) external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}